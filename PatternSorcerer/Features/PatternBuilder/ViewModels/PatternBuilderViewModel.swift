////  PatternBuilderViewModel.swift//  PatternSorcerer////  ViewModel for Visual Pattern Builder////  Created on 2025-11-05//import Combineimport Foundation@MainActorclass PatternBuilderViewModel: ObservableObject {    // MARK: - Published Properties    @Published var components: [PatternComponent] = []    @Published var isLivePreviewEnabled: Bool = true    @Published var currentPatternPreview: String = ""    @Published var validationError: String?    @Published var testText: String = ""    @Published var previewMatches: [String] = []    // MARK: - Computed Properties    var canRemoveComponent: Bool {        !components.isEmpty    }    var canClearPattern: Bool {        !components.isEmpty    }    var isValidPattern: Bool {        validationError == nil && !currentPatternPreview.isEmpty    }    // MARK: - Dependencies    private let builderService: PatternBuilderServiceProtocol    private var cancellables = Set<AnyCancellable>()    // MARK: - Initialization    init(builderService: PatternBuilderServiceProtocol) {        self.builderService = builderService        setupObservers()    }    // MARK: - Setup    private func setupObservers() {        // Update preview when components change        $components            .debounce(for: .milliseconds(100), scheduler: DispatchQueue.main)            .sink { [weak self] _ in                self?.updatePreview()            }            .store(in: &cancellables)        // Update preview matches when test text or pattern changes        Publishers.CombineLatest($testText, $currentPatternPreview)            .debounce(for: .milliseconds(200), scheduler: DispatchQueue.main)            .sink { [weak self] _, _ in                self?.updatePreviewMatches()            }            .store(in: &cancellables)    }    // MARK: - Component Management    func addComponent(_ component: PatternComponent) {        components.append(component)    }    func removeComponent(at index: Int) {        guard index >= 0 && index < components.count else { return }        components.remove(at: index)    }    func editComponent(at index: Int, newComponent: PatternComponent) {        guard index >= 0 && index < components.count else { return }        components[index] = newComponent    }    func moveComponent(from sourceIndex: Int, to destinationIndex: Int) {        guard sourceIndex >= 0 && sourceIndex < components.count,              destinationIndex >= 0 && destinationIndex < components.count else { return }        let component = components.remove(at: sourceIndex)        components.insert(component, at: destinationIndex)    }    func clearPattern() {        components.removeAll()    }    // MARK: - Pattern Generation    func generatePattern() -> String {        do {            let pattern = try builderService.generatePattern(from: components)            currentPatternPreview = pattern            validatePattern()            return pattern        } catch {            validationError = error.localizedDescription            return ""        }    }    // MARK: - Validation    @discardableResult    func validatePattern() -> Bool {        let pattern = generatePattern()        let result = builderService.validatePattern(pattern)        if result.isValid {            validationError = nil        } else {            validationError = result.error        }        return result.isValid    }    // MARK: - Preview    private func updatePreview() {        guard isLivePreviewEnabled else { return }        let _ = generatePattern()    }    private func updatePreviewMatches() {        guard !testText.isEmpty && !currentPatternPreview.isEmpty else {            previewMatches = []            return        }        previewMatches = builderService.previewPattern(currentPatternPreview, with: testText)    }    // MARK: - Actions    func toggleLivePreview() {        isLivePreviewEnabled.toggle()        if isLivePreviewEnabled {            updatePreview()        }    }    func exportPattern() -> String {        let _ = generatePattern()        return currentPatternPreview    }    func importPattern(_ pattern: String) {        // Note: This is a simplified import - full implementation would parse        // the pattern string back into components        clearPattern()        currentPatternPreview = pattern        validatePattern()    }}
