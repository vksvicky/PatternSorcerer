////  PatternBuilderView.swift//  PatternSorcerer////  UI for Visual Pattern Builder////  Created on 2025-11-05//import SwiftUIstruct PatternBuilderView: View {    @StateObject private var viewModel: PatternBuilderViewModel    init(        builderService: PatternBuilderServiceProtocol = PatternBuilderService()    ) {        _viewModel = StateObject(wrappedValue: PatternBuilderViewModel(            builderService: builderService        ))    }    var body: some View {        HSplitView {            // Left side: Component Palette            VStack(spacing: 12) {                SectionContainer(                    title: "Component Palette",                    description: "Drag components to build your pattern"                ) {                    ComponentPaletteSection(viewModel: viewModel)                }            }            .frame(minWidth: 300, maxWidth: 400, maxHeight: .infinity)            Divider()            // Center: Pattern Canvas            VStack(spacing: 12) {                SectionContainer(                    title: "Pattern Canvas",                    description: "Build your pattern visually"                ) {                    PatternCanvasSection(viewModel: viewModel)                }                Divider()                SectionContainer(                    title: "Live Preview",                    description: "Generated pattern string"                ) {                    LivePreviewSection(viewModel: viewModel)                }            }            .frame(minWidth: 400, maxWidth: .infinity, maxHeight: .infinity)            Divider()            // Right side: Test Text and Results            VStack(spacing: 12) {                SectionContainer(                    title: "Test Text",                    description: "Test your pattern against text"                ) {                    TestTextSection(viewModel: viewModel)                }                Divider()                SectionContainer(                    title: "Preview Matches",                    description: "Matches found in test text"                ) {                    PreviewMatchesSection(viewModel: viewModel)                }            }            .frame(minWidth: 300, maxWidth: 400, maxHeight: .infinity)        }        .frame(minWidth: 1200, maxWidth: .infinity, minHeight: 700, maxHeight: .infinity)    }}// MARK: - Component Palette Sectionprivate struct ComponentPaletteSection: View {    @ObservedObject var viewModel: PatternBuilderViewModel    var body: some View {        ScrollView {            VStack(alignment: .leading, spacing: 12) {                ComponentCategoryView(                    title: "Character Classes",                    components: CharacterClassType.allCases.map { .characterClass($0) },                    viewModel: viewModel                )                Divider()                ComponentCategoryView(                    title: "Quantifiers",                    components: QuantifierType.allCases.map { .quantifier($0) },                    viewModel: viewModel                )                Divider()                ComponentCategoryView(                    title: "Anchors",                    components: AnchorType.allCases.map { .anchor($0) },                    viewModel: viewModel                )                Divider()                ComponentCategoryView(                    title: "Groups",                    components: GroupType.allCases.map { .group($0) },                    viewModel: viewModel                )                Divider()                ComponentCategoryView(                    title: "Other",                    components: [.alternation, .custom("")],                    viewModel: viewModel                )            }            .padding()        }    }}// MARK: - Component Category Viewprivate struct ComponentCategoryView: View {    let title: String    let components: [PatternComponent]    @ObservedObject var viewModel: PatternBuilderViewModel    var body: some View {        VStack(alignment: .leading, spacing: 8) {            Text(title)                .font(.headline)                .foregroundColor(.secondary)            LazyVGrid(columns: [GridItem(.adaptive(minimum: 80))], spacing: 8) {                ForEach(components) { component in                    ComponentButton(component: component, viewModel: viewModel)                }            }        }    }}// MARK: - Component Buttonprivate struct ComponentButton: View {    let component: PatternComponent    @ObservedObject var viewModel: PatternBuilderViewModel    var body: some View {        Button(action: {            viewModel.addComponent(component)        }) {            VStack(spacing: 4) {                Image(systemName: component.iconName)                    .font(.title2)                Text(component.displayName)                    .font(.caption)                    .lineLimit(1)            }            .frame(width: 80, height: 60)            .background(Color.gray.opacity(0.1))            .cornerRadius(8)        }        .buttonStyle(.plain)    }}// MARK: - Pattern Canvas Sectionprivate struct PatternCanvasSection: View {    @ObservedObject var viewModel: PatternBuilderViewModel    var body: some View {        VStack(alignment: .leading, spacing: 12) {            if viewModel.components.isEmpty {                emptyStateView(icon: "puzzlepiece", message: "Add components from the palette to build your pattern")            } else {                ScrollView(.horizontal, showsIndicators: true) {                    HStack(spacing: 8) {                        ForEach(Array(viewModel.components.enumerated()), id: \.element.id) { index, component in                            ComponentChip(component: component, index: index, viewModel: viewModel)                        }                    }                    .padding()                }                HStack {                    Button("Clear") {                        viewModel.clearPattern()                    }                    .disabled(!viewModel.canClearPattern)                    Spacer()                    Toggle("Live Preview", isOn: $viewModel.isLivePreviewEnabled)                }                .padding(.horizontal)            }        }        .frame(maxWidth: .infinity, maxHeight: .infinity)    }}// MARK: - Component Chipprivate struct ComponentChip: View {    let component: PatternComponent    let index: Int    @ObservedObject var viewModel: PatternBuilderViewModel    var body: some View {        HStack(spacing: 6) {            Image(systemName: component.iconName)                .font(.caption)            Text(component.displayName)                .font(.caption)            Button(action: {                viewModel.removeComponent(at: index)            }) {                Image(systemName: "xmark.circle.fill")                    .font(.caption)                    .foregroundColor(.secondary)            }            .buttonStyle(.plain)        }        .padding(.horizontal, 8)        .padding(.vertical, 4)        .background(Color.accentColor.opacity(0.2))        .cornerRadius(6)    }}// MARK: - Live Preview Sectionprivate struct LivePreviewSection: View {    @ObservedObject var viewModel: PatternBuilderViewModel    var body: some View {        VStack(alignment: .leading, spacing: 8) {            TextField("Pattern", text: .constant(viewModel.currentPatternPreview))                .font(.system(.body, design: .monospaced))                .textFieldStyle(.roundedBorder)                .disabled(true)            if let error = viewModel.validationError {                HStack {                    Image(systemName: "exclamationmark.triangle")                        .foregroundColor(.red)                    Text(error)                        .font(.caption)                        .foregroundColor(.red)                }            } else if !viewModel.currentPatternPreview.isEmpty {                HStack {                    Image(systemName: "checkmark.circle")                        .foregroundColor(.green)                    Text("Valid pattern")                        .font(.caption)                        .foregroundColor(.green)                }            }        }        .padding()    }}// MARK: - Test Text Sectionprivate struct TestTextSection: View {    @ObservedObject var viewModel: PatternBuilderViewModel    var body: some View {        VStack(alignment: .leading, spacing: 8) {            TextEditor(text: $viewModel.testText)                .font(.system(.body, design: .monospaced))                .frame(minHeight: 150)                .border(Color.gray.opacity(0.3), width: 1)        }        .padding()    }}// MARK: - Preview Matches Sectionprivate struct PreviewMatchesSection: View {    @ObservedObject var viewModel: PatternBuilderViewModel    var body: some View {        VStack {            if viewModel.previewMatches.isEmpty {                if viewModel.testText.isEmpty {                    emptyStateView(icon: "text.magnifyingglass", message: "Enter test text to see matches")                } else {                    emptyStateView(icon: "magnifyingglass", message: "No matches found")                }            } else {                List {                    ForEach(Array(viewModel.previewMatches.enumerated()), id: \.offset) { index, match in                        HStack {                            Text("#\(index + 1)")                                .font(.caption)                                .foregroundColor(.secondary)                            Text(match)                                .font(.system(.body, design: .monospaced))                        }                    }                }                .listStyle(.plain)            }        }    }}
