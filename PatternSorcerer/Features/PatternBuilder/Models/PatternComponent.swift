////  PatternComponent.swift//  PatternSorcerer////  Model for visual pattern builder components////  Created on 2025-11-05//import Foundation/// Represents a component in a visual pattern builderenum PatternComponent: Identifiable, Equatable, Hashable {    case literal(String)    case characterClass(CharacterClassType)    case quantifier(QuantifierType)    case anchor(AnchorType)    case group(GroupType)    case alternation    case custom(String)    var id: UUID {        UUID()    }    /// Display name for the component    var displayName: String {        switch self {        case .literal(let text):            return text        case .characterClass(let type):            return type.rawValue        case .quantifier(let type):            return type.rawValue        case .anchor(let type):            return type.rawValue        case .group(let type):            return type.rawValue        case .alternation:            return "|"        case .custom(let text):            return text        }    }    /// Icon name for the component    var iconName: String {        switch self {        case .literal:            return "text.quote"        case .characterClass:            return "character"        case .quantifier:            return "number"        case .anchor:            return "location"        case .group:            return "parentheses"        case .alternation:            return "arrow.left.arrow.right"        case .custom:            return "puzzlepiece"        }    }}/// Character class types for pattern builderenum CharacterClassType: String, CaseIterable {    case digit = "\\d"    case word = "\\w"    case whitespace = "\\s"    case nonDigit = "\\D"    case nonWord = "\\W"    case nonWhitespace = "\\S"    case any = "."    case custom = "Custom"    var displayName: String {        switch self {        case .digit:            return "Digit"        case .word:            return "Word Character"        case .whitespace:            return "Whitespace"        case .nonDigit:            return "Non-Digit"        case .nonWord:            return "Non-Word"        case .nonWhitespace:            return "Non-Whitespace"        case .any:            return "Any Character"        case .custom:            return "Custom"        }    }    var description: String {        switch self {        case .digit:            return "Matches any digit (0-9)"        case .word:            return "Matches any word character (a-z, A-Z, 0-9, _)"        case .whitespace:            return "Matches any whitespace character"        case .nonDigit:            return "Matches any non-digit character"        case .nonWord:            return "Matches any non-word character"        case .nonWhitespace:            return "Matches any non-whitespace character"        case .any:            return "Matches any character except newline"        case .custom:            return "Custom character class"        }    }}/// Quantifier types for pattern builderenum QuantifierType: String, CaseIterable {    case zeroOrMore = "*"    case oneOrMore = "+"    case zeroOrOne = "?"    case exactly = "{n}"    case atLeast = "{n,}"    case between = "{n,m}"    case custom = "Custom"    var displayName: String {        switch self {        case .zeroOrMore:            return "Zero or More"        case .oneOrMore:            return "One or More"        case .zeroOrOne:            return "Zero or One"        case .exactly:            return "Exactly N"        case .atLeast:            return "At Least N"        case .between:            return "Between N and M"        case .custom:            return "Custom"        }    }    var description: String {        switch self {        case .zeroOrMore:            return "Matches 0 or more occurrences"        case .oneOrMore:            return "Matches 1 or more occurrences"        case .zeroOrOne:            return "Matches 0 or 1 occurrence"        case .exactly:            return "Matches exactly N occurrences"        case .atLeast:            return "Matches at least N occurrences"        case .between:            return "Matches between N and M occurrences"        case .custom:            return "Custom quantifier"        }    }}/// Anchor types for pattern builderenum AnchorType: String, CaseIterable {    case startOfLine = "^"    case endOfLine = "$"    case wordBoundary = "\\b"    case nonWordBoundary = "\\B"    case startOfString = "\\A"    case endOfString = "\\Z"    case custom = "Custom"    var displayName: String {        switch self {        case .startOfLine:            return "Start of Line"        case .endOfLine:            return "End of Line"        case .wordBoundary:            return "Word Boundary"        case .nonWordBoundary:            return "Non-Word Boundary"        case .startOfString:            return "Start of String"        case .endOfString:            return "End of String"        case .custom:            return "Custom"        }    }    var description: String {        switch self {        case .startOfLine:            return "Matches start of line"        case .endOfLine:            return "Matches end of line"        case .wordBoundary:            return "Matches word boundary"        case .nonWordBoundary:            return "Matches non-word boundary"        case .startOfString:            return "Matches start of string"        case .endOfString:            return "Matches end of string"        case .custom:            return "Custom anchor"        }    }}/// Group types for pattern builderenum GroupType: String, CaseIterable {    case capturing = "()"    case nonCapturing = "(?:)"    case positiveLookahead = "(?=)"    case negativeLookahead = "(?!)"    case positiveLookbehind = "(?<=)"    case negativeLookbehind = "(?<!)"    case custom = "Custom"    var displayName: String {        switch self {        case .capturing:            return "Capturing Group"        case .nonCapturing:            return "Non-Capturing Group"        case .positiveLookahead:            return "Positive Lookahead"        case .negativeLookahead:            return "Negative Lookahead"        case .positiveLookbehind:            return "Positive Lookbehind"        case .negativeLookbehind:            return "Negative Lookbehind"        case .custom:            return "Custom"        }    }    var description: String {        switch self {        case .capturing:            return "Captures the matched text"        case .nonCapturing:            return "Groups without capturing"        case .positiveLookahead:            return "Matches if followed by pattern"        case .negativeLookahead:            return "Matches if not followed by pattern"        case .positiveLookbehind:            return "Matches if preceded by pattern"        case .negativeLookbehind:            return "Matches if not preceded by pattern"        case .custom:            return "Custom group"        }    }}
