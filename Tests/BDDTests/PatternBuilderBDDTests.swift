////  PatternBuilderBDDTests.swift//  PatternSorcererTests////  BDD-style tests for Visual Pattern Builder feature////  Created on 2025-11-05//@testable import PatternSorcererimport XCTest@MainActorfinal class PatternBuilderBDDTests: XCTestCase {    var sut: PatternBuilderViewModel!    var mockBuilderService: MockPatternBuilderService!    override func setUp() {        super.setUp()        mockBuilderService = MockPatternBuilderService()        sut = PatternBuilderViewModel(builderService: mockBuilderService)    }    override func tearDown() {        sut = nil        mockBuilderService = nil        super.tearDown()    }    // MARK: - Feature: Adding Components to Pattern    func testFeature_AddComponent_CharacterClass_AddsToPattern() {        // Given: an empty pattern builder        XCTAssertTrue(sut.components.isEmpty, "Pattern should start empty")        // When: adding a character class component        let characterClass = PatternComponent.characterClass(.digit)        sut.addComponent(characterClass)        // Then: component should be added to pattern        XCTAssertEqual(sut.components.count, 1, "Should have one component")        XCTAssertEqual(sut.components.first, characterClass, "Should contain the added component")    }    func testFeature_AddComponent_Literal_AddsToPattern() {        // Given: an empty pattern builder        // When: adding a literal component        let literal = PatternComponent.literal("hello")        sut.addComponent(literal)        // Then: component should be added to pattern        XCTAssertEqual(sut.components.count, 1, "Should have one component")        XCTAssertEqual(sut.components.first, literal, "Should contain the added literal")    }    func testFeature_AddComponent_MultipleComponents_BuildsInOrder() {        // Given: an empty pattern builder        // When: adding multiple components        sut.addComponent(.literal("hello"))        sut.addComponent(.characterClass(.word))        sut.addComponent(.quantifier(.oneOrMore))        // Then: components should be in order        XCTAssertEqual(sut.components.count, 3, "Should have three components")        if case .literal(let text) = sut.components[0] {            XCTAssertEqual(text, "hello", "First component should be literal")        } else {            XCTFail("First component should be literal")        }    }    // MARK: - Feature: Pattern Generation    func testFeature_GeneratePattern_SimpleComponents_GeneratesCorrectPattern() {        // Given: components representing a simple pattern        sut.addComponent(.literal("hello"))        mockBuilderService.patternResult = "hello"        // When: generating pattern string        let pattern = sut.generatePattern()        // Then: should generate correct pattern        XCTAssertEqual(pattern, "hello", "Should generate correct pattern string")        XCTAssertTrue(mockBuilderService.generatePatternCalled, "Should call service to generate pattern")    }    func testFeature_GeneratePattern_ComplexComponents_GeneratesCorrectPattern() {        // Given: complex components (character class + quantifier)        sut.addComponent(.characterClass(.digit))        sut.addComponent(.quantifier(.oneOrMore))        mockBuilderService.patternResult = "\\d+"        // When: generating pattern string        let pattern = sut.generatePattern()        // Then: should generate correct pattern        XCTAssertEqual(pattern, "\\d+", "Should generate correct complex pattern")    }    // MARK: - Feature: Live Preview    func testFeature_LivePreview_UpdatesAutomatically_WhenComponentsChange() {        // Given: pattern builder with live preview enabled        sut.isLivePreviewEnabled = true        mockBuilderService.patternResult = "hello"        // When: adding a component        sut.addComponent(.literal("hello"))        // Then: preview should update automatically        XCTAssertNotNil(sut.currentPatternPreview, "Preview should be available")        XCTAssertEqual(sut.currentPatternPreview, "hello", "Preview should match generated pattern")    }    // MARK: - Feature: Component Removal    func testFeature_RemoveComponent_ByIndex_RemovesFromPattern() {        // Given: pattern with multiple components        sut.addComponent(.literal("a"))        sut.addComponent(.literal("b"))        sut.addComponent(.literal("c"))        // When: removing component at index        sut.removeComponent(at: 1)        // Then: component should be removed        XCTAssertEqual(sut.components.count, 2, "Should have two components remaining")        if case .literal(let text) = sut.components[0] {            XCTAssertEqual(text, "a", "First component should remain")        }        if case .literal(let text) = sut.components[1] {            XCTAssertEqual(text, "c", "Third component should now be second")        }    }    // MARK: - Feature: Component Editing    func testFeature_EditComponent_ModifiesExistingComponent() {        // Given: pattern with a literal component        sut.addComponent(.literal("hello"))        // When: editing the component        sut.editComponent(at: 0, newComponent: .literal("world"))        // Then: component should be updated        if case .literal(let text) = sut.components[0] {            XCTAssertEqual(text, "world", "Component should be updated")        } else {            XCTFail("Component should be literal")        }    }    // MARK: - Feature: Component Reordering (Drag and Drop)    func testFeature_ReorderComponents_MoveComponent_ReordersCorrectly() {        // Given: pattern with multiple components        sut.addComponent(.literal("a"))        sut.addComponent(.literal("b"))        sut.addComponent(.literal("c"))        // When: moving component from index 0 to index 2        sut.moveComponent(from: 0, to: 2)        // Then: components should be reordered        XCTAssertEqual(sut.components.count, 3, "Should still have three components")        if case .literal(let text) = sut.components[0] {            XCTAssertEqual(text, "b", "First component should now be 'b'")        }        if case .literal(let text) = sut.components[2] {            XCTAssertEqual(text, "a", "Last component should now be 'a'")        }    }    // MARK: - Feature: Clear Pattern    func testFeature_ClearPattern_RemovesAllComponents() {        // Given: pattern with components        sut.addComponent(.literal("hello"))        sut.addComponent(.characterClass(.digit))        // When: clearing pattern        sut.clearPattern()        // Then: all components should be removed        XCTAssertTrue(sut.components.isEmpty, "Pattern should be empty")    }    // MARK: - Feature: Pattern Validation    func testFeature_ValidatePattern_ValidPattern_ReturnsValid() {        // Given: a valid pattern        sut.addComponent(.literal("hello"))        mockBuilderService.validationResult = (true, nil)        // When: validating pattern        let isValid = sut.validatePattern()        // Then: should return valid        XCTAssertTrue(isValid, "Pattern should be valid")        XCTAssertTrue(mockBuilderService.validatePatternCalled, "Should call service to validate")    }    func testFeature_ValidatePattern_InvalidPattern_ReturnsInvalid() {        // Given: an invalid pattern        // Note: This would depend on what makes a pattern invalid in the builder        mockBuilderService.validationResult = (false, "Invalid pattern")        // When: validating pattern        let isValid = sut.validatePattern()        // Then: should return invalid        XCTAssertFalse(isValid, "Pattern should be invalid")        XCTAssertNotNil(sut.validationError, "Should have validation error")    }}
