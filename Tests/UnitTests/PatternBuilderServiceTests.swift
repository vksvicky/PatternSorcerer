////  PatternBuilderServiceTests.swift//  PatternSorcererTests////  Unit tests for PatternBuilderService////  Created on 2025-11-05//@testable import PatternSorcererimport XCTestfinal class PatternBuilderServiceTests: XCTestCase {    var sut: PatternBuilderService!    override func setUp() {        super.setUp()        sut = PatternBuilderService()    }    override func tearDown() {        sut = nil        super.tearDown()    }    // MARK: - Generate Pattern    func testGeneratePattern_SimpleLiteral_ReturnsLiteral() throws {        // Given: a simple literal component        let components: [PatternComponent] = [.literal("hello")]        // When: generating pattern        let pattern = try sut.generatePattern(from: components)        // Then: should return literal string        XCTAssertEqual(pattern, "hello", "Should generate literal pattern")    }    func testGeneratePattern_CharacterClass_ReturnsEscapedClass() throws {        // Given: a character class component        let components: [PatternComponent] = [.characterClass(.digit)]        // When: generating pattern        let pattern = try sut.generatePattern(from: components)        // Then: should return escaped character class        XCTAssertEqual(pattern, "\\d", "Should generate digit class")    }    func testGeneratePattern_Quantifier_ReturnsWithQuantifier() throws {        // Given: literal with quantifier        let components: [PatternComponent] = [            .characterClass(.digit),            .quantifier(.oneOrMore)        ]        // When: generating pattern        let pattern = try sut.generatePattern(from: components)        // Then: should include quantifier        XCTAssertEqual(pattern, "\\d+", "Should generate pattern with quantifier")    }    func testGeneratePattern_Anchor_ReturnsWithAnchor() throws {        // Given: anchor with literal        let components: [PatternComponent] = [            .anchor(.startOfLine),            .literal("hello")        ]        // When: generating pattern        let pattern = try sut.generatePattern(from: components)        // Then: should include anchor        XCTAssertEqual(pattern, "^hello", "Should generate pattern with anchor")    }    func testGeneratePattern_Group_ReturnsWithGroup() throws {        // Given: group with content        let components: [PatternComponent] = [            .group(.capturing),            .literal("hello"),            .group(.capturing) // closing        ]        // When: generating pattern        let pattern = try sut.generatePattern(from: components)        // Then: should include group markers        XCTAssertTrue(pattern.contains("("), "Should contain opening parenthesis")        XCTAssertTrue(pattern.contains(")"), "Should contain closing parenthesis")    }    func testGeneratePattern_Alternation_ReturnsWithPipe() throws {        // Given: alternation between literals        let components: [PatternComponent] = [            .literal("hello"),            .alternation,            .literal("world")        ]        // When: generating pattern        let pattern = try sut.generatePattern(from: components)        // Then: should include pipe        XCTAssertEqual(pattern, "hello|world", "Should generate alternation pattern")    }    func testGeneratePattern_ComplexPattern_ReturnsCorrectPattern() throws {        // Given: complex pattern components        let components: [PatternComponent] = [            .anchor(.startOfLine),            .characterClass(.digit),            .quantifier(.oneOrMore),            .literal("-"),            .characterClass(.word),            .quantifier(.zeroOrMore),            .anchor(.endOfLine)        ]        // When: generating pattern        let pattern = try sut.generatePattern(from: components)        // Then: should generate correct complex pattern        XCTAssertEqual(pattern, "^\\d+-\\w*$", "Should generate complex pattern")    }    // MARK: - Validate Pattern    func testValidatePattern_ValidPattern_ReturnsValid() {        // Given: a valid pattern        let pattern = "hello"        // When: validating pattern        let result = sut.validatePattern(pattern)        // Then: should be valid        XCTAssertTrue(result.isValid, "Valid pattern should return true")        XCTAssertNil(result.error, "Should have no error for valid pattern")    }    func testValidatePattern_InvalidPattern_ReturnsInvalid() {        // Given: an invalid pattern        let pattern = "[invalid"        // When: validating pattern        let result = sut.validatePattern(pattern)        // Then: should be invalid        XCTAssertFalse(result.isValid, "Invalid pattern should return false")        XCTAssertNotNil(result.error, "Should have error for invalid pattern")    }    func testValidatePattern_EmptyPattern_ReturnsValid() {        // Given: an empty pattern        let pattern = ""        // When: validating pattern        let result = sut.validatePattern(pattern)        // Then: empty pattern is valid (just matches nothing)        XCTAssertTrue(result.isValid, "Empty pattern should be valid")    }    // MARK: - Preview Pattern    func testPreviewPattern_SimplePattern_ReturnsMatches() {        // Given: a simple pattern and test text        let pattern = "hello"        let testText = "hello world hello"        // When: previewing pattern        let matches = sut.previewPattern(pattern, with: testText)        // Then: should return matches        XCTAssertEqual(matches.count, 2, "Should find two matches")        XCTAssertEqual(matches[0], "hello", "First match should be 'hello'")        XCTAssertEqual(matches[1], "hello", "Second match should be 'hello'")    }    func testPreviewPattern_NoMatches_ReturnsEmpty() {        // Given: a pattern that doesn't match        let pattern = "xyz"        let testText = "hello world"        // When: previewing pattern        let matches = sut.previewPattern(pattern, with: testText)        // Then: should return empty array        XCTAssertTrue(matches.isEmpty, "Should return no matches")    }}
